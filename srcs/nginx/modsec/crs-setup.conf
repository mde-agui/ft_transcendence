# OWASP ModSecurity Core Rule Set (CRS) Setup Configuration
# ft_transcendence: Paranoia Level 3, strict anomaly scoring

# -- Rule engine initialization ----------------------------------------------

# Enable ModSecurity, attaching it to every transaction. Use detection
# only to start with, because that minimises the chances of post-installation
# disruption.
#
SecRuleEngine On

# -- Request body handling --------------------------------------------------

# Allow ModSecurity to access request bodies. If you don't, ModSecurity
# won't be able to inspect requests with bodies, and you won't be able to
# use its full capabilities.
#
SecRequestBodyAccess On

# Enable XML request body parser.
# Initiate XML Processor in case a XML request is detected.
#
SecRule REQUEST_HEADERS:Content-Type "text/xml" \
	"id:200000,\
	 phase:1,\
	 t:none,\
	 t:lowercase,\
	 pass,\
	 nolog,\
	 ctl:requestBodyProcessor=XML"

# Enable JSON request body parser.
# Initiate JSON Processor in case a JSON request is detected.
#
SecRule REQUEST_HEADERS:Content-Type "application/json" \
     "id:200001,\
	  phase:1,\
	  t:none,\
	  t:lowercase,\
	  pass,\
	  nolog,\
	  ctl:requestBodyProcessor=JSON"

# Maximum request body size we will accept for buffering. If you support
# file uploads then the value given on the first line has to be as large
# as the largest file you are willing to accept. The second value refers
# to the temporary directory where the data is stored while it is being
# processed. Inspection of -very- large bodies (say over 512K) can be slow,
# so the value is limited.
#
SecRequestBodyLimit 13107200
SecRequestBodyNoFilesLimit 131072

# Store up to 128 KB of request body data in memory. When the multipart
# parser reachers this limit, it will start using your hard disc for
# storage. That is slow, but unavoidable.
#
SecRequestBodyInMemoryLimit 131072

# What do do if the request body size is above our configured limit.
# Keep in mind that this setting will automatically be set to ProcessPartial
# when SecRuleEngine is set to DetectionOnly mode in order to minimize
# disruptions when initially deploying ModSecurity.
#
SecRequestBodyLimitAction Reject

# Verify that we've correctly processed the request body.
# As a rule of thumb, when failing to do so you want to reject the
# request, when everything else is ready.
#
SecRule REQBODY_ERROR "!@eq 0" \
	"id:200002,\
	 phase:2,\
	 t:none,\
	 log,\
	 deny,\
	 status:400,\
	 msg:'Failed to parse request body.',logdata:'%{reqbody_error_msg}',severity:2"

# By default be strict with what we accept in the multipart/form-data
# request body. If the rule below proves to be too strict for your
# environment consider changing it to detection only. You are encouraged
# _not_ to remove it altogether.
#
SecRule MULTIPART_STRICT_ERROR "!@eq 0" \
	"id:200003,\
	 phase:2,\
	 t:none,\
	 log,\
	 deny,\
	 status:400,\
	 msg:'Multipart request body \
	 failed strict validation: \
	 PE %{REQBODY_PROCESSOR_ERROR}, \
	 BQ %{MULTIPART_BOUNDARY_QUOTED}, \
	 BW %{MULTIPART_BOUNDARY_WHITESPACE}, \
	 DB %{MULTIPART_DATA_BEFORE}, \
	 DA %{MULTIPART_DATA_AFTER}, \
	 HF %{MULTIPART_HEADER_FOLDING}, \
	 LF %{MULTIPART_LF_LINE}, \
	 SM %{MULTIPART_MISSING_SEMICOLON}, \
	 IQ %{MULTIPART_INVALID_QUOTING}, \
	 IP %{MULTIPART_INVALID_PART}, \
	 IH %{MULTIPART_INVALID_HEADER_FOLDING}, \
	 FL %{MULTIPART_FILE_LIMIT_EXCEEDED}'"

# Did we see anything that might be a boundary attack?
#
SecRule MULTIPART_BOUNDARY_ATTACK "@eq 1" \
	"id:200003-A,\
	 phase:2,\
	 t:none,\
	 log,\
	 deny,\
	 status:400,\
	 msg:'Multipart parser detected a possible unmatched boundary.'"

# PCRE Tuning
# We want to avoid a potential RegEx DoS condition
#
SecPcreMatchLimit 100000
SecPcreMatchLimitRecursion 100000

# Some internal errors will set flags in TX and we will need to look for these.
# All of these are infrastructure problems, so we want to terminate the request
# in their presence.
#
SecRule TX:/^MSC_/ "!@streq 0" \
	"id:200004,\
	 phase:2,\
	 t:none,\
	 deny,\
	 msg:'ModSecurity internal error flagged: %{MATCHED_VAR_NAME}'"


# -- Response body handling -------------------------------------------------

# Allow ModSecurity to access response bodies. 
# You should have this directive enabled in order to fully enjoy its features.
#
SecResponseBodyAccess On

# Which response MIME types do you want to inspect? You should adjust the
# configuration below to catch documents but avoid static files
# (e.g., images and archives).
#
SecResponseBodyMimeType text/plain text/html text/xml application/xml text/json

# Buffer response bodies of up to 512 KB in length.
SecResponseBodyLimit 524288

# What happens when we encounter a response body larger than the configured
# limit? By default, we process what we have and let the rest through.
# That's somewhat less secure, but does not break any legitimate pages.
#
#SecResponseBodyLimitAction ProcessPartial

# -- Filesystem configuration -----------------------------------------------

# The location where ModSecurity stores temporary files (for example, when
# it needs to handle a file that is too big to store in memory).
#
# This default setting is usually OK, but you need to make sure it is
# writable by the user the web server runs as (usually www, apache, or such).
# Use an absolute path.
#
SecTmpDir /tmp/

# The location where ModSecurity will keep its storage data.
# This default setting is usually OK, but it must be an absolute path,
# and it should be private to ModSecurity. This pathname must be writable
# by the user the web server runs as (usually www, apache, or such), too.
#
SecDataDir /tmp/

# -- File uploads handling configuration ------------------------------------

# The location where ModSecurity stores intercepted uploaded files. This
# location must be private to ModSecurity. You can use the %{TXID} variable
# to generate unique names to help prevent conflicts.
#
# This default setting is usually OK, but you need to make sure it is
# writable by the user the web server runs as (usually www, apache, or such).
# Use an absolute path.
#
SecUploadDir /tmp/

# By default, only keep the files that were determined to be unusual
# in some way (by an external inspection script). For this to work you
# will also need at least one file inspection rule.
#
SecUploadKeepFiles RelevantOnly

# Uploaded files are by default preserved. This is desirable only in situations
# where you might need to manually review the uploaded files as that is time
# and disk space consuming. 
#
SecUploadFileMode 0600


# -- Debug log configuration ------------------------------------------------

# The default debug log configuration is to duplicate the error, warning
# and notice messages from the error log.
#
SecDebugLog /var/log/modsec_debug.log
SecDebugLogLevel 3


# -- Audit log configuration ------------------------------------------------

# Log the transactions that have triggered a warning or an error
# or have a status code that is considered unusual (not 200, 304, or 302).
#
SecAuditEngine RelevantOnly
SecAuditLogRelevantStatus "^(?:5|4(?!04))"

# Log everything we know about a transaction.
SecAuditLogParts ABIJDEFHZ

# Use a single file for logging. This is much easier to look at, but
# assumes that you will use the audit log only occasionally.
#
SecAuditLogType Serial
SecAuditLog /var/log/modsec_audit.log


# -- Rule exceptions and anomaly scoring ------------------------------------

# Paranoia Level Setting
# Hardened for ft_transcendence: Set to PL3 for strict protection
SecAction \
  "id:900000,\
    phase:1,\
    nolog,\
    pass,\
    t:none,\
    setvar:tx.paranoia_level=3"

# Inbound and Outbound Anomaly Score Threshold
# Lowered for stricter blocking: Block if inbound score >4, outbound >3
SecAction \
  "id:900110,\
    phase:1,\
    nolog,\
    pass,\
    t:none,\
    setvar:tx.inbound_anomaly_score_threshold=4,\
    setvar:tx.outbound_anomaly_score_threshold=3"

# CRS Anomaly Scoring Blocking Modes
# ON: Blocking mode enabled (recommended for production)
SecAction \
  "id:900200,\
    phase:1,\
    nolog,\
    pass,\
    t:none,\
    setvar:tx.crs_enable_blocking_mode=1"

# Default Actions for Disruptive Rules
SecDefaultAction "phase:1,log,auditlog,deny,status:403"
SecDefaultAction "phase:2,log,auditlog,deny,status:403"

# Rule Exclusions for False Positives (tune as needed)
# Example: Exclude WebSocket upgrades for game module
SecRuleRemoveById 981173  # Common false positive for WebSockets
SecRuleUpdateTargetById 981173 !REQUEST_HEADERS:Upgrade

# More exclusions if needed (e.g., for JSON bodies in auth/game)
SecRule REQUEST_URI "@beginsWith /game" \
	"id:900300,\
	 phase:1,\
	 nolog,\
	 pass,\
	 ctl:ruleRemoveById=942100-942999"  # Exclude SQLi rules for game if false positives
